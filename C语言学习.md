# 									C语言折腾日记

# 一.C语言的环境配置

C语言的环境设置主要由文本编译器和C编译器组成

## 1.文本编译器:

windows上可以使用notepad

linux上可以使用vim/vi

## 2.C语言编译器:

常用的编译器为GCC
### (1).win上安装C语言环境
windows上要安装**MinGW**,因为上面会有GCC的安装。在选择安装时要选择gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。

win环境变量设置:
添加您安装的 MinGW 的 bin 子目录到您的 **PATH** 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。
### (2).linux上安装C语言环境
linux上安装先检查是否装有GCC

```shell
$ gcc -v
```

会给出以下反馈

```shell
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none:amdgcn-amdhsa
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
Thread model: posix
Supported LTO compression algorithms: zlib zstd
gcc version 11.2.0 (Ubuntu 11.2.0-7ubuntu2) 
```

搭建C语言环境

```shell
$ sudo apt upgrade
$ sudo apt-get install vim
$ sudo apt-get install gcc
$ sudo apt-get install build-essential		#编译程序必须软件包的列表信息
```

## 二.第一个C语言程序

```c
#include <stdio.h>      		//这是函数头//
int main()						//main是程序的入口//	
{
    float num;
    num = 1;
    printf("Do you like van you see?.\n");
    printf("I just like %f.\n",num);
    getchar();
    num = 2;
    printf("Do you like van you see?.\n");
    printf("I just like %f.\n",num);
    getchar();
    return 0;
    /*我是注释，我是注释adiwhiadkasn*/

}

```

在编辑好之后使用下面命令创造一个可运行的C程序

```
$ gcc -Wall text1.c -o text1
#-o text1 是创建一个名字为text1的C程序

$ ./text1					#运行该程序
```

一个C程序由函数头和函数组成

这是一个最简单的C程序

```c
#include <stdio.h>
int main()
/*123 */     // 123 // 
{
	return 0
}
```

备注一下这个最简单的小程序

1. 程序的第一行 *#include <stdio.h>* 是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。
2. 下一行 *int main()* 是主函数，程序从这里开始执行。
3. 下一行 /*...*/ 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。
4. 下一行 **return 0;** 终止 main() 函数，并返回值 0。











# 一.C语言里面的数据类型

最基本的四种类型

| 序号 | 类型与描述                                                   |
| :--: | :----------------------------------------------------------- |
|  1   | **基本类型：** 它们是算术类型，包括五种类型：整数类型、浮点类型、字符类型、布尔类型和枚举类型。 |
|  2   | **指针类型：** 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。 |
|  3   | **void 类型（空类型）：** 类型说明符 *void* 表明没有可用的值。 |
|  4   | **构造类型：** 它们包括：数组类型、结构类型、共用体类型和函数类型。 |



## 1.整型: 原码, 反码, 补码的基础概念和计算方法.

在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式. 

### (1)原码

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

> [+1]原 = 0000 0001
>
> [-1]原 = 1000 0001

第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

> [1111 1111 , 0111 1111] 

即

> [-127 , 127]

原码是人脑最容易理解和计算的表示方式.

### (2)反码

反码的表示方法是:

正数的反码是其本身

负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

> [+1] = [00000001]原 = [00000001]反
>
> [-1] = [10000001]原 = [11111110]反

可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.

### (3)补码

补码的表示方法是:

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

> [+1] = [00000001]原 = [00000001]反 = [00000001]补
>
> [-1] = [10000001]原 = [11111110]反 = [11111111]补

对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.

## 2.浮点数类型的储存原理

首先c编译系统把浮点型常量都是按双精度处理,分配8个字节(64位)

对于浮点类型的数据采用单精度类型(float)和双精度类型(double)来存储，float数据占用 32bit,double数据占用 64bit.其实不论是float类型还是**double类型**，在计算机内存中的存储方式都是遵从IEEE的规范的，float 遵从的是IEEE R32.24 ,而double 遵从的是R64.53。   

无论是单精度还是双精度，在内存存储中都分为3个部分：  

1) 符号位(Sign)：0代表正，1代表为负；  
2) 指数位(Exponent)：用于存储科学计数法中的指数数据，并且采用移位存储； 
3) 尾数部分(Mantissa)：尾数部分

float数据类型:

![img](https://img-blog.csdn.net/20160904101057305?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

double数据类型:

![img](https://img-blog.csdn.net/20160904101108331?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

下面就看看8.25和120.5在内存中真正的存储方式： 

8.25用二进制的科学计数法表示为:1.0001*2^3  按照上面的存储方式，符号位为0，表示为正；

指数位为3+127=130，位数部分为 1.00001

故8.25的存储方式如下：  0xbffff380:    01000001000001000000000000000000 

分解如下：0--10000010--00001000000000000000000  

符号位为0，指数部分为10000010，位数部分为 00001000000000000000000 




同理，120.5在内存中的存储格式如下：  0xbffff384:    01000010111100010000000000000000 

分解如下：0--10000101--11100010000000000000000 

总结:浮点数的储存是以指数的方式储存的 



## 3.char数据类型

char类型可以储存字符和字符串

但char实际上是一种特殊的整型

当储存一个在ASCll中的字符的时候,此时整数类型输出的是相应的的ASCll的值,而输出单个字符才是其真正的字符。

`` char 变量名[数量]``是一个字符串,但要注意的是字符串的储存方式:最后一个字符是/0,作为识别**字符串结束位置**的标志

但是计算机可以自动去计算字符串的数量,应此常用``char 变量名[]``用空括号。

字母大小写的ASCll码转换:``+32可以改变字母大小写``




## 4.基本类型

基本类型包括整数和浮点数,具体的讨论如下:

一个字节储存八位无符号数:范围0~255

| 类型           | 存储大小    | 值范围                                               |
| -------------- | ----------- | ---------------------------------------------------- |
| char           | 1 字节      | -128 到 127 或 0 到 255                              |
| unsigned char  | 1 字节      | 0 到 255                                             |
| signed char    | 1 字节      | -128 到 127                                          |
| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节      | -32,768 到 32,767                                    |
| unsigned short | 2 字节      | 0 到 65,535                                          |
| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4 字节      | 0 到 4,294,967,295                                   |
|                |             |                                                      |
|                |             |                                                      |

| 整数类型      | 浮点数类型  | 字符类型 | 布尔类型 | 枚举类型 |
| ------------- | ----------- | -------- | -------- | -------- |
| short int     | float       | char     | _Bool    | enum     |
| int           | double      |          |          |          |
| long int      | long double |          |          |          |
| long long int |             |          |          |          |
|               |             |          |          |          |

不同类型所占的空间不同,根据合适的去选择是最好的

## 5.格式说明符号

连续打两个%就可以输出%号了

%d 有符号10进制整数 

%u 无符号10进制整数 

%i 有符号10进制整数 ,***而%i 则可以匹配八进制、十进制、十六进制表示的整数***

%o 无符号8进制整数(octal number system) 

%x 无符号的16进制数字，并以小写abcdef表示(hexadecimal)

%X 无符号的16进制数字，并以大写ABCDEF表示

%F/f 浮点数 

%E/e 用科学表示格式的浮点数 

%g 使用%f和%e表示中的总的位数表示最短的来表示浮点数 G 同g格式，但表示为指数 

%c 单个字符 

%s 字符串

%p 地址数据

%l 后面加d,i,f等表示长(long)

%f本身是8位,最多保留7位精度

%7.2f 输出7位,保留2位精度

但是要注意防止越界!!!

??

%m:

%n:

-:输出的字符或数字在域内向左

```
%m.nd：m为指定的输出字段的宽度，n定义为实际输出的个数。
m>0时为右对齐，根据n的大小，不足在左边补0；
m<0时和m>0好像没有区别；
如果省略m或者n，则m=n；
如果只有m且不指定空位填0，根据m的正负值，空位以空格补齐。
```

```c
int main(void)
{
    int a = 123;
    printf("m.nd : %5.5d\n", a);    //打印  00123
    printf("-m.nd : %-5.5d\n", a);  //打印  00123
    printf(".nd : %.5d\n", a);      //打印  00123
    printf("m.d : %5.d\n", a);      //打印    123
    printf("md : %5d\n", a);        //打印    123
    printf("md : %05d\n", a);       //指定空位补0：打印  00123
    system("pause");
    return EXIT_SUCCESS;
}
```



注意:当需要强制转换格式的时候可以加()来进行转换

```C
#include <stdio.h>
int main()
{
	printf("整数输出:%d\n", 1 + (int)1.8);//强制转换会把小数直接抹去,输出不是3,而是2
    printf("整数输出:%d\n", 1 + (int)(1 + 0.8));
    return0
}
```





```C
#include <stdio.h>
int main()
{
    char number1 = 1;								输出的是asc码里的1
    char number2 = '1';								输出的是字符1
    printf("%d, %d \n", number1, number2);
    // unsigned int num = 2,147,483,647//
    printf("%d, %u \n", -123, -123);				输出的结果根据%d和%u输出的解析方式不一样,结果不一样
    return 0;
}


mhy@mhy-dxz:~/Learning$ ./a.out
1, 49 
-123, 4294967173 
```



## 6.声明(变量)

声明就是去定义一个变量，这在python中是一样的。

```python
		a = 123
		type a
out[1]: int
```

这是在python中去定义一个变量，在python中可以直接给予变量名，赋值和数据类型。

但是这在c/c++中是不可以的

```c
int num;
num = 123;
int num = 123;
```

在c里命名变量要先定义变量的数据类型，再去给变量定义内容。但是变量是可以重新赋值的，同python一样(python同C一样)。

当要进行多个变量声明的时候用','隔开。

```C
int number1, number2;
int number1 = 1, number2 = 2;
```

但是注意变量的声明是将变量值放到内存中的一个地址当中。

C语言中的标识符号:可以用数字,字母,下划线,但是不能以数字为开头。区分大小写





## 7.数组

数组的定义

`` 数据类型 数组名[元素个数]``

```c
int shuzu[10];
//在这个里面shuzu这个数组一共有10个元素
//但是元素是0~9,所以要单独提取数组元素的时候要这样:
//shuzu[0]~shuzu[9],不能是a[10]
```

- 循环和数组的关系:因为数组的首项为0,所以在使用循环的时候通常用`` i=0``来初始化计数器,防止越界问题的出现。

数组的第一个元素的地址和数组的地址是一样的，之后每个元素的地址在第一个元素的地址上加数据类型的长度

数组的初始化

数组的初始化是将所有元素赋值,没有说明的会自动变成0

```C
/*将所有元素初始化*/
int a[10] = {0}; //实际只把第一个赋值为0,其余默认为0
int a[10] = {1,2,3,4,5};  //这样前五个元素分别是1,2,3,4,5 而其余元素为0
int a[] = {1,2,3,4,5,6,7,8,9,0};  //之前说过编译器会自动匹配出元素的个数
//又是C99
int a[10] = {[3] = 3, [5] = 5, [6] = 6};  //就和python一样,只不过没赋值的数还会变成0
sizeof (a) //会输出数组的字节数
```

在C99当中是支持动态数组的,也就是说可以用变量来当元素数量

```C
#include <stdio.h>
int main(){
	int n;
	printf("please input chars number: ");
	scanf("%d", &n);
	char a[n+1];
	printf("输入:");
	getchar();
	for(int i = 0;i < n; i++){
		scanf("%c", &a[i]);
	}
	a[n] = '\0';		//这个一定不要忘记
	printf("repeat:%s\n", a);
	return 0;
}


同时最新的编译器甚至还有越界保护.....挺离谱的
```

## 8.二维数组

本质上二维数组就是一维数组的堆叠。

- 二维数组的定义:

``类型 数组名[常量表达式(行)][常量表达式(列)] ``

``int a[n][n];``



- 二维数组的访问:

`` a[2][3]``访问第二行第三个数(同时也要注意越界问题)



- 下面是数组在内存中的储存方式:

``b[4][5]``

就是将二维用一维的方式表示出来。

| b[0] | b[1] | b[2] | b[3] |
| ---- | ---- | ---- | ---- |

| b[0] [0] | b[0] [1] | b[0] [2] | b[0] [3] | b[0] [4] | b[1] [0] | b[1] [1] | b[1] [2] | b[1] [3] | b[1] [4] | b[2] [0] | b[2] [1] | b[2] [2] | b[2] [3] | b[2] [4] | b[3] [0] | b[3] [1] | b[3] [2] | b[3] [3] | b[3] [4] |
| -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |



- 二维数组的初始化

一共有三种初始化的形式,但是常用最后一种。

```c
//第一种根据内存储存的方式,初始化
int a[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
//第二种直观一些
int a[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
//第三种最直观
int a[3][4] = {
		{1, 2, 3, 4},
		{5, 6, 7, 8},
		{9, 10, 11, 12}
};
```

- 二维数组的部分赋值

```c
//这是对每一行第一列赋值,或着说是大括号表示的是行
int a[3][4] = {{1}, {2}, {3}};
//这是将数组全部初始化为0
int a[3][4] = {0};
//这是C99的新特性,直接对指定的位置进行赋值
int a[3][4] = {[0][0] = 1, [1][1] = 2};
//偷懒赋值,但只有第一维的元素个数可以不写,当然编译器会自动识别数量的
int a[][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
```

- **二维数组的输出**(这个很重要)

```c
#include <stdio.h>
int main{
	int a[3][4] = {
		{1, 2, 3, 4},
		{5, 6, 7, 8},
		{9, 10, 11, 12}
	};
	int i, j;
	for(i = 0; i < 3; i++){
		for(j = 0, j < 4, j++){
			printf("%d ", a[i][j]);
		}
		printf("\n");
	}
	return 0;
}

//将矩阵转换方向,将i和j的位置互换,改变量名和条件
#include <stdio.h>
int main{
	int a[3][4] = {
		{1, 2, 3, 4},
		{5, 6, 7, 8},
		{9, 10, 11, 12}
	};
	int i, j;
	for(i = 0; i < 4; i++){
		for(j = 0, j < 3, j++){
			printf("%d ", a[j][i]);
		}
		printf("\n");
	}
	return 0;
}
```



## 9.多维数组







## 10.字符串和字符数组

编译器通过结尾的`` \0``来判断是不是字符串。

字符串常量:确定下来不能改变

没有赋值的数组结果为'\0',打印出来只有赋值的字符串

```C
int main(){
	char string[10];
	string[0] = 'I';
	string[1] = 'L';
	string[2] = 'O';
	string[3] = 'V';
	string[4] = 'E';
	string[5] = 'D';
	string[6] = 'X';
	string[7] = 'Z';
	string[8] = '!';
	string[9] = '\0';
}

```

字符数组:相对灵活

```C
int main(){
	char string[] = {'I','L','O','V','E','D','X','Z','\0'};
	// 可以写也可以不写元素的个数,编译器会自动计算元素数量.
	char string[] = {"I LOVE DONGXIAOZUO"};
	// 可以用字符串常量来直接初始化数组.
	char string[] = "我爱董笑佐";
	// 可以省略大括号直接将字符串常量初始化.  推荐这种写法!!!!
}
```



# 二.一些标记符号

###### ``signed``

一般默认都会带有符号(就是有正号和负号)

###### `` unsigned``

加上之后就是没有符号

###### `` const``

C99常变量,不能改变其值,但是常变量占用内存

###### `` #define 变量名 内容``

但是宏变量没有地址,只是一种替换

我们将其放在函数头中



# 三.一些基本的运算符

## 1.杂项运算符 ↦ sizeof & 三元

下表列出了 C 语言支持的其他一些重要的运算符，包括 **sizeof** 和 **? :**。

| 运算符   | 描述             | 实例                                 |
| -------- | ---------------- | ------------------------------------ |
| sizeof() | 返回变量的大小。 | sizeof(a) 将返回 4，其中 a 是整数。  |
| &        | 返回变量的地址。 | &a; 将给出变量的实际地址。           |
| *        | 指向一个变量。   | *a; 将指向一个变量。                 |
| ? :      | 条件表达式       | 如果条件为真 ? 则值为 X : 否则值为 Y |

## 2.算术运算符

下表显示了 C 语言支持的所有算术运算符。假设变量 **A** 的值为 10，变量 **B** 的值为 20，整数相除的时候要注意四舍五入

则：

| 运算符 | 描述                             | 实例                   |
| ------ | -------------------------------- | ---------------------- |
| +      | 把两个操作数相加                 | A + B 将得到 30        |
| -      | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10       |
| *      | 把两个操作数相乘                 | A * B 将得到 200       |
| /      | 分子除以分母                     | B / A 将得到 2         |
| %      | 取模运算符，整除后的余数         | B % A 将得到 0         |
| ++     | 自增运算符，整数值增加 1         | A++ 将得到 11          |
| --     | 自减运算符，整数值减少 1         | A-- 将得到 9           |
| +=     | 自加后面再增加(默认有括号)       | a+=x+1 将得到a=a+(x+1) |



## 3.关系运算符

下表显示了 C 语言支持的所有关系运算符。假设变量 **A** 的值为 10，变量 **B** 的值为 20，则：

| 运算符 | 描述                                                         | 实例            |
| ------ | ------------------------------------------------------------ | --------------- |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 为假。 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。 |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 为假。  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。  |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 为假。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。 |

## 4.逻辑运算符

下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 **A** 的值为 1，变量 **B** 的值为 0，则：

| 运算符 | 描述                                                         | 实例              |
| ------ | ------------------------------------------------------------ | ----------------- |
| &&     | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。         | (A && B) 为假。   |
| \|\|   | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 | (A \|\| B) 为真。 |
| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态。(把假变真,把真变假) 如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。  |

短路求值(最小化求值)

```c
#include <stdio.h>
int main()
{
	int a = 3, b = 3;
	(a = 0) && (b = 5);
	printf("a = %d, b = %d\n", a, b);
    (a = 1) || (b = 5);
	printf("a = %d, b = %d\n", a, b);	//简单理解就是先看前面的条件,如果能直接判断,就不再看后面的条件了
	return 0;
}


out[0]:a = 0, b = 3
       a = 1, b = 3
```





## 5.位运算符

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p    | q    | p & q | p \| q | p ^ q |
| ---- | ---- | ----- | ------ | ----- |
| 0    | 0    | 0     | 0      | 0     |
| 0    | 1    | 0     | 1      | 1     |
| 1    | 1    | 1     | 1      | 0     |
| 1    | 0    | 0     | 1      | 1     |

| 运算符 | 描述                                                         | 实例                                                         |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| &      | 按位与操作，按二进制位进行"与"运算。运算规则： `0&0=0;    0&1=0;     1&0=0;      1&1=1;` | (A & B) 将得到 12，即为 0000 1100                            |
| \|     | 按位或运算符，按二进制位进行"或"运算。运算规则： `0|0=0;    0|1=1;    1|0=1;     1|1=1;` | (A \| B) 将得到 61，即为 0011 1101                           |
| ^      | 异或运算符，按二进制位进行"异或"运算。运算规则： `0^0=0;    0^1=1;    1^0=1;   1^1=0;` | (A ^ B) 将得到 49，即为 0011 0001                            |
| ~      | 取反运算符，按二进制位进行"取反"运算。运算规则： `~1=-2;    ~0=-1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| <<     | 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000                            |
| >>     | 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 | A >> 2 将得到 15，即为 0000 1111                             |

## 6.赋值运算符

下表列出了 C 语言支持的赋值运算符：

| 运算符 | 描述                                                         | 实例                            |
| ------ | ------------------------------------------------------------ | ------------------------------- |
| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |
| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |
| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |
| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于  C = C << 2      |
| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于  C = C >> 2      |
| &=     | 按位与且赋值运算符                                           | C &= 2 等同于  C = C & 2        |
| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于  C = C ^ 2        |
| \|=    | 按位或且赋值运算符                                           | C \|= 2 等同于  C = C \| 2      |

## 7.C 中的运算符优先级

运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。(算关赋)

例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。

下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。

| 类别       | 运算符                                      | 结合性   |
| ---------- | ------------------------------------------- | -------- |
| 后缀       | () [] -> .  ++   - -                        | 从左到右 |
| 一元       | +  -   !  ~  ++  - -   (type)*  &  sizeof   | 从右到左 |
| 乘除       | *  /  %                                     | 从左到右 |
| 加减       | +  -                                        | 从左到右 |
| 移位       | << >>                                       | 从左到右 |
| 关系       | < <=  > >=                                  | 从左到右 |
| 相等       | ==  !=                                      | 从左到右 |
| 位与 AND   | &                                           | 从左到右 |
| 位异或 XOR | ^                                           | 从左到右 |
| 位或 OR    | \|                                          | 从左到右 |
| 逻辑与 AND | &&                                          | 从左到右 |
| 逻辑或 OR  | \|\|                                        | 从左到右 |
| 条件       | ?:                                          | 从右到左 |
| 赋值       | =  +=  -=  *=  /=  %=>>=  <<=  &=  ^=   \|= | 从右到左 |
| 逗号       | ,                                           | 从左到右 |

## 8.在学指针时出现的运算符

| 运算符                 | 符号 | 作用                                                 |
| ---------------------- | ---- | ---------------------------------------------------- |
| 取址运算符             | &    | 获取某个变量的地址:char *pa = &a;                    |
| 取值运算符(间接运算符) | *    | 访问指针变量指向的数据:printf("%c, %d\n", *pa, *pb); |
|                        |      |                                                      |
|                        |      |                                                      |



# 四.常用的语句{}

{}表示一个语句块或者叫程序块

在条件判断的时候要注意`` =``和``==``

## 1.if语句

里面的判断表达式是判断0(不执行)或非0(执行)值

### (1)if

```c
if (表达式或者条件)
{
	(执行的语句块)
}
```

```C
#include <stdio.h>
int main()
{
	int i;
	scanf("%d", &i);	//&的作用:取i的地址(指针会学)
	if (i >= 18)
	{
		printf("TURE\n");
	}
	return 0;
}
```

### (2)if-else

```C
if(表达式)
{
	(执行的语句块)
}
else
{
    (执行的语句块)
}

```

```C
#include <stdio.h>
int main()
{
	int i;
	scanf("%d", &i);	//&的作用:取i的地址(指针会学)
	if (i >= 18)
	{
		printf("TURE\n");
	}
    else
    {
        printf("False\n");
    }
	return 0;
}
```

### (3)if-else if-else

```c
if(表达式1)
{
	(执行的语句块)
}
else if(表达式2)
{
    (执行的语句块)
}
else if(表达式3)
{
    (执行的语句块)
}
......
else
{
    (执行的语句块)
}

```

## 2.switch语句

```
switch(表达式)
{
	case 常量表达式1: 语句块; break;
	case 常量表达式2: 语句块; break;
	......
	default: 语句块; break;
}
```

case相当于一个程序的入口,没有break的时候会一次向下执行语句(比如空语句`` case a:``)

switch()括号里的表达式是一个入口(由真假来判断),但case的常量表达式可以和switch里面的变量值对应:

```C
int a;
scanf("%d",&a);
switch(a){
	//下面会根据a的值来对应执行的case
	case 1: 语句块; break;
	case 2: 语句块; break;
	......
	default: 语句块; break;
}
```

但是switch中不能用contiune,因为这个并不是一个循环,但是可以选择将switch用在for函数中嵌套,这样就可以正常运行了

## 3.循环嵌套

循环的结构组成

~~~ C
int count = 0;				//初始化计数器
while (count < 10)			//循环条件
{
	语句块;
	count ++;				//更新计数器
}
~~~



在嵌套语句中常用的函数用break和continue

但是break只能跳出本层循环

## 4.while和do while

```
while(表达式)
{
	循环体
}
```

```c
#include <stdio.h>
int main()
{
	int i = 1, sum = 0;
	while(i <= 100)
	{
		sum += i;
		i ++;
	}
	printf("%d\n", sum);
    return 0;
}
```

```C
#include <stdio.h>
int main()
{
	int count = 0;
	printf("Please input a sentence: ");
	while(getchar() != '\n')
	{
		count ++;
	}
	printf("These are %d chars!\n", count);
	return 0;
}
```

这里要注意区分while 和 do-while的区别

while是先循环再去执行

而do-while 是先执行再去循环


```
do
{
	循环体
}
	
while(表达式);
```



## 5.for语句循环

for循环的格式`` for(表达式1;表达式2;表达式3;)``
其中表达式1指的是初始化条件(多个初值用``,``相隔),表达式2指的是循环条件,表达式3一般为自增或自减。

在初始化条件当中一般会定义一个变量,用来判断条件是否为真。而真的条件是True也就是一个非零的数(不一定就是1,但是一般都会用1来表示),而假的条件是False也就是一个为零的数。

但是在**C99 **当中表达式1中可以定义变量

```c
//stand C99//
for (int i = 0; i <= 9; i++);
//usual stand C//
int i 
for (i = 0; i <= 9; i++);
//注意在通常的C语言当中只能在第一个表达式当中定义变量的变量值//
```

同时for循环也可以这样使用(就是在for循环中添加循环体):

```C
#include <stdio.h>
int main()
{
	int i = 1, sum = 0;
	for( 1; i <= 100; i++)
	{
		sum += i;
	}
	printf("%d\n", sum);
	return 0;
}
```

## 6.break和continue

break语句是跳出当前循环,然后停止循环。

continue语句是跳出条件的循环,然后继续循环,或者可以说跳过循环的语句块,然后在开始循环。

上实例:

```C
#include <stdio.h>
int main ()
{
   int a = 10;
   /* do 循环执行 */
   do
   {
      if( a == 15)
      {
         /* 跳过迭代 */
         a = a + 1;
         continue;
      }
      printf("a 的值： %d\n", a);
      a++;  
   }
   while( a < 20 );
   return 0;
}
```

```
out[0]:
a 的值： 10
a 的值： 11
a 的值： 12
a 的值： 13
a 的值： 14
a 的值： 16
a 的值： 17
a 的值： 18
a 的值： 19
因为跳过了a = 15的这一次循环
```











# 五.一些基本函数

## 1.<stdio.h>

###### `printf()`

将文字打印在屏幕上,同python里面的print();

输出的时候会先输出，在进行加减

```c
int a = 10;
printf("%d", a++);
//会先输出a,在将a进行赋值运算
```



###### `scanf()`

用户输入信息,将信息传输给程序,同python里面的input();

###### `getchar()`

等待用户的操作

###### ` main()`

主函数,程序的入口

## 2.<string.h>(剩下的自己学)

###### `` strlen()``

获得字符串长度,而不是字符串的尺寸,也就是说不包含'\0'。

需要注意的是:该函数使用后的数据类型为unsigned int,所以一般用`` %u``来打印。

###### ``  strcpy``&&`` strncpy``

拷贝字符串

注意字符串不能用赋值号来赋值

``strcpy(目标字符串,拷贝字符串)``,这个会涉及到溢出问题

``strncpy(目标字符串,拷贝字符串,拷贝元素数)``但是这样拷贝的不会自动添加``\0``(C99当中可能加入了自动补全'\0')

```c
#include <stdio.h>
#include <string.h>
int main(){
	char string_one[] = "我爱董笑佐";
    char string_two[];
    // 这种写法是错误的: string_one = string_two;
    strcpy(string_two, string_one);
    // 但是要注意拷贝的字符串长度会不会溢出的问题
}
```

###### `` strcat``&&`` strncat``

连接字符串,字符串的拼接

``strcat(拼接函数1,拼接函数2)``结果会放到拼接函数1当中,同时会破坏拼接函数2

``strncat(拼接函数1,拼接函数2, 拼接函数2的元素数)``这个是先把拼接函数2变成后面所填元素数的个数,在按照strcat的方式拼接,同样的最好自己手动加上``\0``(C99中可能加入了自动补全'\0')

```C
//我的新发现
//在使用strcat的时候是将两个字符串拼接,但同时将两个字符串的内容都改变了
比如:string[] = "woaidongxiaozuo"
    实际上是有16个元素"woaidongxiaozuo\0"
    string2[] = "woaidongxiao"
    实际上是有13个字符"woaidongxiao\0"
    stract(string, string2)n
    结果是string变成了"woaidongxiaozuowoaidongxiao\0"
    而string2变成了"oaidongxiao\0"
    将'w'与'\0'置换的同时,也将'w'取走到string里面了
```





`` strcmp``&&`` strbcmp``

比较字符串

从第一个字符开始比较字符串元素中的ASCII码的值

如果一致就返回`` 0``

如果第一个字符串的ASCII码小于第二个字符串的ASCII码,则返回小于0的值

如果第一个字符串的ASCII码大于第二个字符串的ASCII码,则返回大于0的值

`` strcmp(str1, str2)``

```C
#include <stdio.h>
#include <string.h>
int mian()
{
	char password1[100] = "123456";
	char password2[100] = "123456";
	if(!strcmp(password1, password2))
	{
		printf("两次密码一样\n");
	}
	else
	{
		printf("两次密码存在差异\n");
	}
	return 0;
}
```









# 六.C语言里面的杂项

## 注释

```c
/* */
```

对的，这是一个注释，里面什么都可以输入，这种注释的好处是可以用到多行。

```c
// //
```

这也是一种注释，但是这种注释只能用于单行。

## debug

debug(调试)是找出并修正错误的过程。

## debugger

debugger(调试器)是用来调试debug的程序。

## 32位和64位

**从程序上说**：32位与64位程序，是指经过语言编译后的可执行文件，比如 C 语言编写的程序就需要区分是32位的还是64位

**从系统和硬件上讲**：CPU一次处理数据的能力是32位还是64位，关系着系统需要安装32位还是64位的系统

32 位和 64 位中的“位”，也叫字长，是 CPU 通用寄存器的数据宽度，是数据传递和处理的基本单位。字长是 CPU 的主要技术指标之一，指的是 CPU 一次能并行处理的二进制位数，字长总是8的整数倍

## ASCII

**ASCII码表**

| **ASCII值** | **控制字符** | **ASCII值** | **控制字符** | **ASCII值** | **控制字符** | **ASCII值** | **控制字符** |
| ----------- | ------------ | ----------- | ------------ | ----------- | ------------ | ----------- | ------------ |
| 0           | NUL          | 32          | (space)      | 64          | @            | 96          | 、           |
| 1           | SOH          | 33          | ！           | 65          | A            | 97          | a            |
| 2           | STX          | 34          | ”            | 66          | B            | 98          | b            |
| 3           | ETX          | 35          | #            | 67          | C            | 99          | c            |
| 4           | EOT          | 36          | $            | 68          | D            | 100         | d            |
| 5           | ENQ          | 37          | %            | 69          | E            | 101         | e            |
| 6           | ACK          | 38          | &            | 70          | F            | 102         | f            |
| 7           | BEL          | 39          | '            | 71          | G            | 103         | g            |
| 8           | BS           | 40          | (            | 72          | H            | 104         | h            |
| 9           | HT           | 41          | )            | 73          | I            | 105         | i            |
| 10          | LF           | 42          | *            | 74          | J            | 106         | j            |
| 11          | VT           | 43          | +            | 75          | K            | 107         | k            |
| 12          | FF           | 44          | ,            | 76          | L            | 108         | l            |
| 13          | CR           | 45          | -            | 77          | M            | 109         | m            |
| 14          | SO           | 46          | .            | 78          | N            | 110         | n            |
| 15          | SI           | 47          | /            | 79          | O            | 111         | o            |
| 16          | DLE          | 48          | 0            | 80          | P            | 112         | p            |
| 17          | DCI          | 49          | 1            | 81          | Q            | 113         | q            |
| 18          | DC2          | 50          | 2            | 82          | R            | 114         | r            |
| 19          | DC3          | 51          | 3            | 83          | X            | 115         | s            |
| 20          | DC4          | 52          | 4            | 84          | T            | 116         | t            |
| 21          | NAK          | 53          | 5            | 85          | U            | 117         | u            |
| 22          | SYN          | 54          | 6            | 86          | V            | 118         | v            |
| 23          | TB           | 55          | 7            | 87          | W            | 119         | w            |
| 24          | CAN          | 56          | 8            | 88          | X            | 120         | x            |
| 25          | EM           | 57          | 9            | 89          | Y            | 121         | y            |
| 26          | SUB          | 58          | :            | 90          | Z            | 122         | z            |
| 27          | ESC          | 59          | ;            | 91          | [            | 123         | {undefined   |
| 28          | FS           | 60          | <            | 92          | \            | 124         | \|           |
| 29          | GS           | 61          | =            | 93          | ]            | 125         | }            |
| 30          | RS           | 62          | >            | 94          | ^            | 126         | ~            |
| 31          | US           | 63          | ?            | 95          | —            | 127         | DEL          |



![img](https://img-blog.csdnimg.cn/d928b7623b72440887d11e79541fc4e2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6K-t5Yaw55qE6ICB5aSP6Jmr,size_20,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/9fa6a0cb6db9480f9d62667e931cec58.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6K-t5Yaw55qE6ICB5aSP6Jmr,size_17,color_FFFFFF,t_70,g_se,x_16)



## i++和++i

`` i++``先赋值i再自增1,而``++i``是先自增1再赋值i(也就是赋值i + 1)。

`` i--``和``--i``同上

## lvalue&&rvalue

​	左值是用来指明一个对象的表达式。最简单的左值就是变量名称。一个左值表示一个对象，它可以出现在``赋值运算符``的左边，例如“左表达式=右表达式”。

 	其他表达式（那些表示一个值但不指明一个对象的），被类似地称为右值（rvalue）。右值是可以出现在赋值运算符右边而不是左边的表达式。例如，常量和算术表达式。

​	 从一个左值中必定可以解析出对应对象的地址，除非该对象是位字段（bit-field）或者被声明为寄存器存储类。生成左值的运算符包括下标运算符``[]``和间接运算符``*``，如下表所示（如果 array 已被声明为数组，而 ptr 被声明为指针变量）。

| 表达式    | 是左值吗                                     |
| --------- | -------------------------------------------- |
| array[1]  | 是；一个数组元素是一个具有位置的对象         |
| &array[1] | 否；此对象的位置，并非一个具有位置的对象     |
| ptr       | 是；此指针变量是一个具有位置的对象           |
| *ptr      | 是；指针所指的地方是一个具有位置的对象       |
| ptr+1     | 否；此加法产生一个新的地址值，但不是一个对象 |
| *ptr+1    | 否；此加法产生一个新的算术值，但不是一个对象 |


 对象可以被声明为常量。在这种情况下，该对象就不能位于赋值运算的左边，尽管它是左值，如下面的例子所示：

```
int a=1;const int b=2, *ptr=&a;b=20;           
//错误：b被声明为const int*ptr=10;        
//错误：ptr被声明为const int的指针
```

在这个例子中，表达式 a、b、ptr 和 *ptr 都是左值。但是 b 和 *ptr 是常量左值。因为 ptr 被声明为指向 const int 的指针，不能使用它修改它所指向的对象。

 赋值运算左边的操作数，以及任何自增或自减运算符（++ 和 --）的操作数，不仅应该是左值，还应该是可修改的左值。可修改的左值，其类型不可以被声明为限定符 const，并且可修改的左值不能是数组类型。如果可修改的左值所表示的对象是结构或联合类型，那么它的元素都不可以被声明（不管是直接地或间接地）为具有限定符 const 的类型。





# 给自己加一点思考题

1.32位和64位对现代计算机的影响,以及C语言在不同位的计算机上的好处。                                                      

2.关于学习C语言发现strncpy和strncat是否补全'\0'的疑问(自学分享,记录一下)

本人使用的操作系统 ``ubuntu 21.10 x86_64``
使用的编译器是 ``gcc version 11.2.0``
在C语言学习的过程中(我看的是18年的c语言学习视频),学到``strncpy``和``strncat``的用法,视频中的演示使用这两个函数后面不补充``'\0'``的话会报错,但是我自己尝试了一下,没有加``'\0'``,却成功运行了。
下面是代码：

```C
#include<stdio.h>
#include<string.h>
int main(){
  char string_one[] = "zheshiyigezifuchuan";
  char string_two[50];
  strncpy(string_two, string_one, 10);
  printf("%s\n", string_one);
  printf("%s\n", string_two);
  return 0;
}
```
strncat的使用和上面是一样的代码。
不知道是不是C99或者C11新增加的内容。
本人记录下来,方便自己查看,也欢迎有相同疑问的朋友互相来讨论。

3.常考题型：素数判断

# 七.指针!!!!!

## 1.变量是如何存放的

每一个变量都是放在储存器中的地址里(内存储放数据)

| 地址   | 存放的值 |
| ------ | -------- |
| ...... | ......   |
| 10000  | 'I'      |
| 10001  | 'L'      |
| 10002  | 'O'      |
| 10003  | 'V'      |
| ...... | ......   |
| 10010  | 123      |
| 10011  |          |
| 10012  |          |
| 10013  |          |

注:从10010-10013一共是四个字节,存放一个3个字符的字符串(毕竟最后有一个\0)

## 2.指针和指针变量

(一个指针占用四个字节,指针是用来存放变量的地址,比如说一个地址为10001,这个地址对应的是'a\'这个值,而我们建立一个指针pa,里面存放的是'10001这个地址',所对应的是'a'这个值)

简单点说:指针存放的是变量的``地址``(10001),而指针里存放的这个地址(10001)的``空间(内存的具体位置)``叫做指针变量

指针变量的初始化:

`` 类型名 *指针变量名``

```c
char *pa;	//定义一个指向字符型的指针变量
//也就是说a是一个字符型
int *pb;	//定义一个指向整型的指针变量
//也就是说b是一个整型
```

注意:一定要避免间接访问未初始化的指针(因为不知道会把什么覆盖掉),不然可能电脑就会寄了

但实际上更推荐将指针初始化为空指针`` int *pa = NULL`` 

```c
#include<stdio.h>
int main(){
        char a = 'F';
        int b = 123;
    	//下面两步就叫做初始化指针
        char *pa = &a;
        int *pb = &b;
        printf("a = %c\n", *pa);
        printf("b = %d\n", *pb);
        *pa = 'M';
        *pb += 1;
        printf("a = %c\n", *pa);
        printf("b = %d\n", *pb);
        printf("sizeof pa = %ld\n", sizeof(pa));
        printf("sizeof pb = %ld\n", sizeof(pb));
        printf("address of a is: %p\n", pa);
        printf("address of b is: %p\n", pb);
        return 0;
}
```

- 不同的访问方式

前提:

```c
char a = 'a';
char *pa = &a;
```

直接访问:``printf("a = %c\n", a);``

间接访问:`` printf("a = %c\n", *pa);``

下面是一个检验指针是否为空的方法:

```c

if(ptr)     /* 如果 p 非空，则完成 */
if(!ptr)    /* 如果 p 为空，则完成 */

```

## 3.数组和指针

指针方面的一些小回顾

```c
int a = 1;
int *p = &a;
scanf("%d", &a);
scanf("%d", p);
//在这里面，&a和p（指针）都是表示变量的地址；*p表示的是指针变量
char string[128];
scanf("%s", string);
//在这里，数组也不需要打印&取址运算符，所以数组名实际上就是一个地址
printf("address: %p\n", string);
printf("address: %p\n", &string[0]);
//输出的地址是一样的，注意元素要用&取址运算符
```

数组名**指向**数组第一个元素的地址

```C
#include<stdio.h>

int main{
	char string[128];
	printf("please input the strings:");
	scanf("%s",string); //也就是说string也可以看作一个地址
	printf("address: %p\n", string);
	printf("address: %p\n", &string[0]);
	//输出结果是一样的,
	return 0;
}
```

数组的地址是根据变量类型一次递增，例如：char,每个地址+1.

下面定义一个指针指向数组

```c
char a[];
char *p;
p = a;
p = &a[0];
//取元素第一个地址
char *p = a
```

到了这里，体现出了指针的第一个功能：指针的运算

## 4.指针的运算

当指针指向数组元素的时候，我们可以对指针变量进行加减运算，这样做的意义可以通过指针所在的位置向前或者向后查找元素（听上去有亿点像循环查找元素） 

```c
char a[] = "LOVE DXZ";
char *p = a;
printf("%c %c %c", *p,*(p+1),*(p+2));
//在p+1,并不是将地址加一，而是单纯的的寻找下一个元素，因为在定义数字和指针的类型的时候，就已经自动在地址加上一个类型字节的长度，所以指向的就是元素了。//
```

```c
//在数组当中也可以这样
char b[] = "LOVE DXZ"
printf("%c %c %c", *b,*(b+1),*(b+2));
//结果也是可以正常访问的
```

所以可以用指针建立字符串哈哈哈哈，然后用指针读取元素。。。

```c
#include <stdio.h>
#include <string.h>
int main{
	char *str = "I LOVE DXZ";
	int i, length;
	length = strlen(str);
	for(i = 0; i < length; i++){
		printf("%c",str[i]);
	}
	printf("\n");
	return 0;
}
```

指针的自增运算输出元素：要求是一个左值（注意要是能更改的变量）

所以在这个时候就不能用数组的地址来自增，因为数组的地址是一个常量，这时候就需要定义一个指针来指向数组，然后对指针进行自增或者自减运算

```c
#include <stdio.h>
int main(){
	char str[] = "I LOVE DXZ";
	char *target = str;
	int count = 0;
	
	while(*target++ )
}
```











# 算法

## 排序算法![](https://www.runoob.com/wp-content/uploads/2019/03/sort.png)

### 冒泡算法

![](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)



算法步骤：

```
1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。

2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

3.针对所有的元素重复以上的步骤，除了最后一个。

4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

```

函数写法

```c
#include <stdio.h>
void bubble_sort(int arr[], int len) {
        int i, j, temp;
        for (i = 0; i < len - 1; i++)
                for (j = 0; j < len - 1 - i; j++)
                        if (arr[j] > arr[j + 1]) {
                                temp = arr[j];
                                arr[j] = arr[j + 1];
                                arr[j + 1] = temp;
                        }
```

