<!doctype html>
<html>

<!-- Mirrored from python.freelycode.com/contribution/detail/47 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 25 Apr 2022 11:00:00 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="做国内最权威,最活跃的Python社区.帮助Pythoner的技术快速提升,关心Pythoner的工作和生活,紧紧追随Python领域的前沿技术.">
  <link rel="shortcut icon" href="https://qiniumedia.freelycode.com/pythoncircle/img/favicon.ico" />
  <meta name="keywords" content="Python,python,python学习,python教程,python题目,python培训,python精品文章,python论坛,程序员,部落">
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title> PEP8中文版 -- Python编码风格指南 </title>

  <!-- Set render engine for 360 browser -->
  <meta name="renderer" content="webkit">

  <!-- Add to homescreen for Chrome on Android -->
  <meta name="mobile-web-app-capable" content="yes">

  <!-- Add to homescreen for Safari on iOS -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Amaze UI"/>

  <!-- Tile icon for Win8 (144x144 + tile color) -->
  <meta name="msapplication-TileColor" content="#0e90d2">
  <link rel="stylesheet" href="https://qiniumedia.freelycode.com/pythoncircle/css/bootstrap.min.css" />
  <script type="text/javascript" src="https://qiniumedia.freelycode.com/pythoncircle/lib/jquery/jquery-1.9.1.min.js"></script>
  <script type="text/javascript" src="https://qiniumedia.freelycode.com/pythoncircle/lib/draggabilly.pkgd.min.js"></script>
  <style type="text/css">
  @media (min-width: 1200px) {
    #headerContainer {
      width: 1170px;
      padding: 5px 15px 5px 15px;
    }
  }
  @media (min-width: 992px) and (max-width: 1199px) {
    #headerContainer {
      width: 970px;
      padding: 5px 15px 5px 15px;
    }
  }
  @media (min-width: 768px) and (max-width: 991px) {
    #headerContainer {
      width: 750px;
      padding: 5px 15px 5px 15px;
    }
  }
  @media (max-width: 767px) {
    #headerContainer {
      width: 100%;
      padding: 5px 15px 5px 15px;
    }
    .headerMenu {
      display: none;
    }
  }
  html, body {
    background-color: #f9f9f9;
    overflow-x: hidden;
  }
  img {
    max-width: 100%;
  }
  div#footer {
    color: #888;
    padding: 20px;
    vertical-align: middle;
  }
  div.container {
    min-height: 500px;
  }
  #header {
    background-color: #fff;
    box-shadow: #ccc 0px 0px 3px;
    border: 0px;
    position: fixed;
    top: 0px;
    width: 100%;
    z-index: 999;
    border-radius: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #headerContainer {
    height: 54px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  #headerLeft {
    height 44px;
    display: flex;
    align-items: center;
  }
  #headerLeft img {
    width: 200px;
  }
  #headerRight {
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  #headerAvatar {
    display: block;
    width: 36px;
    height: 36px;
    border-radius: 6px;
    cursor: pointer;
  }
  .headerMenu {
    height: 40px;
    padding: 5px 10px 5px 10px;
    line-height: 30px;
    font-size: 16px;
    color: #999;
    margin-left: 10px;
    cursor: pointer;
  }
  .oneLineText {
    text-overflow: ellipsis;
    overflow: hidden;
    display: -webkit-box;
    word-wrap: break-word;
    white-space: normal !important;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical;
    text-overflow: -o-ellipsis-lastline;
  }
  </style>
</head>
<body>
<img src="https://qiniumedia.freelycode.com/pythoncircle/img/icon_121_75.png" style="display:none;" alt="" />
<div id="header">
  <div id="headerContainer">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div id="headerLeft">
      <a href="https://python.freelycode.com/">
        <img src="https://qiniumedia.freelycode.com/vcdn/1/Python部落网站/logo1.png" />
      </a>
      <div class="headerMenu">
        <div class="headerMenuTitle" onclick="window.location.href='https://python.freelycode.com/fcode/downloadinstall'">
          软件下载及安装
        </div>
      </div>
    </div>
    <div id="headerRight">
      
        <a href="https://python.freelycode.com/accounts/login/" class="btn btn-primary">登录</a>
      
    </div>
    <!--
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">文档<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="/doc/python_2_7_10/">Python2.7.10文档</a></li>
            <li><a href="/doc/python_3_5_0/">Python3.5.0文档</a></li>
            <li><a href="/doc/python2_stdlib_blog/">Python2标准库示例集合</a></li>
            
            
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">辅助工具<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="/fcode/visualexe">可视化执行过程</a></li>
            <li><a href="/fcode/game">有营养的游戏</a></li>
            <li><a href="/fcode/jsonformat">JSON格式化工具</a></li>
          </ul>
        </li>
      </ul>
      <form class="navbar-form navbar-left" role="search" action="/fcode/search">
        <div class="form-group">
          <input type="text" class="form-control" name="keyword" placeholder="关键词">
        </div>
        <button type="submit" class="btn btn-primary">搜</button>
      </form>
    </div>
    -->
  </div>
</div>
<div class="container" style="margin-top: 80px;">
  
<div class="row">
  <div class="col-sm-12">
    <ol class="breadcrumb">
      <li><a href="https://python.freelycode.com/">首页</a></li>
      
      <li><a href="https://python.freelycode.com/contribution/list/2">Python编辑器文章</a></li>
      
      <li class="active">PEP8中文版 -- Python编码风格指南</li>
    </ol>
  </div>
</div>
<div class="row">
  <div class="col-sm-2">
    &nbsp;
  </div>
  <div class="col-sm-8">
    <div class="well">
      <div class="title" style="font-size: 36px; font-weight: bold; border-bottom: 1px solid #ccc; margin-bottom: 20px; padding-bottom: 20px;">
        PEP8中文版 -- Python编码风格指南
      </div>
      <div class="content">
        
        <blockquote><p>Python部落组织翻译, 禁止转载</p></blockquote><p style="text-indent: 0em;"><span style="font-size: 18px;"><strong>目录</strong></span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缩进<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 制表符还是空格？<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 行的最大长度<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 空行<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 源文件编码<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 导入<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 无法忍受的<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其它建议<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注释块<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 行内注释<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文档字符串<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 根本原则<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 描述：命名风格<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 规定：命名约定</p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;"><span style="font-size: 18px;"><strong>介</strong></span><strong>绍</strong></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;">本文档所提供的编码规范，适用于主要的Python发行版中组成标准库的Python代码。请参阅PEP关于Python的C实现的C编码风格指南的描述[1]。<br/><br/>本文档和PEP257（文档字符串规范）改编自Guido的《Python Style Guide》一文，用Barry的风格指南[2]做一些补充。<br/><br/>这篇风格指南随着时间的推移而逐渐演变，随着语言本身的变化，过去的约定已经过时了并确定了更多新的约定。<br/><br/>许多项目都有自己的编码风格指南。如果有任何冲突，优先使用该项目特定的指南。</p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;"><span style="font-size: 18px;"><strong>令人讨厌的小人物身上愚蠢的一致性</strong></span><br/></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;">Guido的一个重要的见解是，代码阅读的次数比编写的次数多。这里提供的指南旨在提高代码的可读性，并使各种不同的Python代码一致。如PEP20所说，“易读性非常重要”。<br/><br/>风格指南是关于一致性的。与本风格指南一致很重要。项目中的一致性更重要。一个模块或功能中的一致性最重要。<br/><br/>最重要的是：知道何时会不一致——有时风格指南就不适用了。怀疑时，作出你最佳的判断。看看其他的例子，并决定什么是最好的。不要犹豫，尽管发问！<br/><br/>特别地：不要只为遵从这个PEP而打破向后兼容性！<br/><br/>忽视既定指南的一些其他的好理由：<br/>1、当应用指南会降低代码的可读性，即使对于那些习惯遵照这个PEP来阅读代码的人来说。<br/>2、与周围的代码保持一致也会破坏它（可能是历史原因）——虽然这也是收拾别人烂摊子的好机会（在真正的XP风格中）。<br/>3、因为问题代码先于指南，又没有其它的修改理由。<br/>4、代码需要兼容老版本，本风格指南不建议使用的Python特性。</p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;"><span style="font-size: 18px;"><strong>代码布局</strong></span></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;"><strong>缩进</strong><br/></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;">每级缩进使用4个空格。<br/>连续行应该对齐折叠元素，无论是垂直的Python的隐式行连接圆括号内的，中括号内的，大括号内的，还是使用悬挂缩进[5]。使用悬挂缩进应注意以下几点；</p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;">第一行没有参数并且使用更多的缩进来区别它本身和连续行。</p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;">风格良好：</p><p style="text-indent: 0em;"><img src="https://qiniumedia.freelycode.com/1/b355dea29f5344a2ac8eafbb27fc81d6.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;"><br/>风格不良：</p><p style="text-indent: 0em;"><img src="https://qiniumedia.freelycode.com/1/7cc22501c6ff4459bd51f81cae040a6d.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;"><br/>对于连续行，4个空格规则是可选的。<br/>可选的：<br/><img src="https://qiniumedia.freelycode.com/1/a73febfbc2664182915e0f11b207df32.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;"><br/>if语句条件块足够长时需要编写多行，值得注意的是两个字符组成的关键字（例如if），加上一个空格，加上开括号为多行条件的后续行创建一个4个空格的缩进。这可以给嵌入if内的缩进语句产生视觉冲突，这也自然被缩进4个空格。这个PEP没有明确如何（是否）进一步区分条件行和if语句内的嵌入行。这种情况下，可以接受的选项包括，但不仅限于：</p><p style="text-indent: 0em;"><img src="https://qiniumedia.freelycode.com/1/9150dcc9003b40da92e1acacaf25f732.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;"><br/>多行结构中的结束花括号/中括号/圆括号是最后一行的第一个非空白字符，如：</p><p style="text-indent: 0em;"><img src="https://qiniumedia.freelycode.com/1/37e45b53d3524feab25ff3b5c59019a5.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;">或者是最后一行的第一个字符，如：</p><p style="text-indent: 0em;"><img src="https://qiniumedia.freelycode.com/1/10d16786fb934830a7bca5ac9139649c.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;"><span style="font-size: 16px;"><strong>制表符还是空格？</strong></span></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;">空格是缩进方法的首选。<br/>制表符仅用于与已经用制表符做缩进的代码保持一致。<br/>Python3不允许混用制表符和空格来缩进。<br/>Python2代码混用制表符和空格缩进，将被转化为只使用空格。<br/>调用Python2命令行解释器时使用-t选项，可对代码中非法混用制表符和空格发出警告。当使用-tt选项，警告将变成错误。这些选项是高度推荐的！</p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;"><strong>行的最大长度</strong></p><p style="text-indent: 0em;"><br/>限制所有行最多79个字符。<br/><br/>下垂的长块结构限制为更少的文本（文档字符串或注释），行的长度应该限制在72个字符。<br/><br/>限制编辑器窗口宽度使得并排打开多个文件成为可能，并且使用代码审查工具显示相邻列的两个版本工作正常。<br/><br/>绝大多数工具的默认折叠会破坏代码的可视化结构，使其更难以理解。编辑器中的窗口宽度设置为80个字符。即使该工具将在最后一列中标记字形。一些基于网络的工具可能不会提供动态的自动换行。<br/><br/>有些团队强烈喜欢较长的行长度。对于代码维护完全或主要由一个团队的，可以在这个问题上达成协议，象征性的将行长度从80个字符增加到100个字符（有效地增加最大长度到99个字符）也是可以的，提供注释和文档字符串仍是72个字符。<br/><br/>Python标准库采取保守做法，要求行限制到79个字符（文档字符串/注释到72个字符）。<br/><br/>折叠长行的首选方法是在小括号，中括号，大括号中使用Python隐式换行。长行可以在表达式外面使用小括号来变成多行。连续行使用反斜杠更好。<br/><br/>反斜杠有时可能仍然是合适的。例如，长的多行的with语句不能用隐式续行，可以用反斜杠：</p><p style="text-indent: 0em;"><img src="https://qiniumedia.freelycode.com/1/efc81345c76c49418a2ef88d33ee96a9.png" title="" alt="article4.png"/><br/></p><p style="text-indent: 0em;">（为进一步思考With语句的多行缩进，见前面多行if语句的讨论。）<br/></p><p style="text-indent: 0em;"><br/>另一个这样的例子是assert语句。<br/><br/>确保适当的连续行缩进。</p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;"><strong>换行应该在二元操作符的前面还是后面？</strong></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;">过去二十年我们都是推荐放在二元操作符的后面。但是这种做法会以两种方式伤害可读性：多个二元操作符在屏幕上不在一列，另外如果你想知道对一个被操作的对象做了什么操作，需要向上找一行。这导致你的眼睛不得不上下往返很多次才能搞清楚哪个数字是被加的，哪个数字是被减的：</p><p style="text-indent: 0em;"><img src="https://qiniumedia.freelycode.com/1/e9732f3c6ab44dbb95fe722d9bf7a105.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;">为了解决可读性问题，数学家和印刷业者通常是在二元操作符之前换行的。Donald Knuth在他的《计算机与排版》系列文章中解释了这个传统规则：“虽然写在一段话中的公式经常在二元操作符的后面换行，但是单独展示的公式通常是在二元操作符的前面换行。”</p><p style="text-indent: 0em;">出于遵循数学传统，所以我们这样写这段代码将更加可读：</p><p style="text-indent: 0em;"><img src="https://qiniumedia.freelycode.com/1/61a1a2f9210940b0bdeba8cadecce930.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;"><strong>空行</strong></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;">顶级函数和类的定义之间有两行空行。<br/><br/>类内部的函数定义之间有一行空行。<br/><br/>额外的空行用来（谨慎地）分离相关的功能组。相关的行（例如：一组虚拟实现）之间不使用空行。<br/><br/>在函数中谨慎地使用空行来表示逻辑部分。<br/><br/>Python接受control-L（即^L）换页符作为空白符；许多工具把这些字符作为分页符，所以你可以使用它们为文件中的相关部分分页。注意，一些编辑器和基于Web的代码查看器可能不能识别control-L是换页，将显示另外的字形。<br/></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;"><strong>源文件编码</strong><br/></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;">Python核心发布中的代码应该始终使用UTF-8（或Python2中用ASCII）。<br/>文件使用ASCII（Python2中）或UTF-8（Python3中）不应有编码声明。<br/><br/>在标准库中，非默认编码仅用于测试目的或注释或文档字符串需要提及包含非ASCII字符的作者名；否则，使用\x，\u，\U，或\N是字符串中包含非ASCII数据的首先方式。<br/><br/>Python3.0及以上版本，为标准库（参见PEP 3131）规定以下策略：Python标准库中的所有标识符必须使用ASCII标识符，在可行的地方使用英文单词（在很多例子中，使用非英文的缩写和专业术语）。另外，字符串和注释必须用ASCII。仅有的例外是（a）测试非ASCII的特点，（b）测试作者名。不是基于拉丁字母表的作者名必须提供一个他们名字的拉丁字母表的音译。<br/><br/>开源项目面向全球，鼓励采用统一策略。<br/></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;"><strong>导入</strong></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;">导入通常是单独一行，例如：<br/>风格良好：</p><p style="text-indent: 0em;"><img src="https://qiniumedia.freelycode.com/1/ace9e82a1ce64810940e6bf3976022ec.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;"><br/>风格不良：</p><p style="text-indent: 0em;"><img src="https://qiniumedia.freelycode.com/1/de9b7c8aaf864cd78593ab43831bfc55.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;">这样也是可以的：<br/></p><p style="text-indent: 0em;"><img src="https://qiniumedia.freelycode.com/1/7305340ed62d4cf6bb4d018fed91cdc9.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;"><br/>导入常常位于文件顶部，在模块注释和字符串文档之后，在模块的全局变量和常量之前。<br/><br/>导入应该按照以下顺序分组：<br/>1. 标准库导入<br/>2. 相关的第三方导入<br/>3. 特定的本地应用/库导入<br/>在每个导入组之间放一行空行。<br/><br/>把任何相关__all__规范放在导入之后。<br/>推荐绝对导入，因为它们更易读，并且如果导入系统配置的不正确（例如当包中的一个目录结束于sys.path）它们有更好的表现（至少给出更好的错误信息）：<br/><img src="https://qiniumedia.freelycode.com/1/50a99ab2f4854bd793534097758f58e6.png" title="" alt="article4.png"/><br/>明确的相对导入可以用来接受替代绝对导入，特别是处理复杂包布局时，绝对导入过于冗长。<br/><img src="https://qiniumedia.freelycode.com/1/4009405d56c94806aec3650d1c308938.png" title="" alt="article4.png"/><br/>标准库代码应该避免复杂包布局并使用绝对导入。<br/>隐式的相对导入应该永远不被使用，并且在Python3中已经移除。<br/>从一个包含类的模块中导入类时，通常下面这样是好的写法：<br/><img src="https://qiniumedia.freelycode.com/1/1503a134c28b467eb50874957b1783ba.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;">如果这种写法导致本地名字冲突，那么就这样写：<br/><img src="https://qiniumedia.freelycode.com/1/c6ee6faccbc0454a8ee2a00198eaa1db.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;">并使用“myclass.MyClass”和“foo.bar.yourclass.YourClass”来访问。<br/>避免使用通配符导入（from &lt;模块名&gt; import *），因为它们使哪些名字出现在命名空间变得不清楚，这混淆了读者和许多自动化工具。通配符导入有一种合理的使用情况，重新发布一个内部接口作为一个公共API的一部分（例如，重写一个纯Python实现的接口，该接口定义从一个可选的加速器模块并且哪些定义将被重写提前并不知道）。<br/><br/>用这种方式重新命名，下面的有关公共和内部接口的指南仍适用。</p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;"><strong>模块级别的内置属性</strong></p><p style="text-indent: 0em;"><br/></p><p style="text-indent: 0em;">模块级别的内置属性（名字有前后双下划线的），例如__all__, __author__, __version__，应该放置在模块的文档字符串后，任意import语句之前，from __future__导入除外。Python强制要求from __future__导入必须在任何代码之前，只能在模块级文档字符串之后。</p><p style="text-indent: 0em;"><img src="https://qiniumedia.freelycode.com/1/1296472c4bed46b3a7a7810114c8c4fd.png" title="" alt="article4.png"/></p><p style="text-indent: 0em;"><br/></p><p><strong>字符串引号</strong></p><p><br/></p><p>Python中，单引号字符串和双引号字符串是一样的。本PEP不建议如此。建议选择一条规则并坚持下去。当一个字符串包含单引号字符或双引号字符时，使用另一种字符串引号来避免字符串中使用反斜杠。这提高可读性。<br/><br/>三引号字符串，与PEP 257 文档字符串规范一致总是使用双引号字符。</p><p><br/></p><p><strong>表达式和语句中的空格</strong></p><p><br/></p><p><em>无法忍受的</em></p><p><em><br/></em></p><p>以下情况避免使用多余的空格：</p><p><br/></p><p>紧挨着小括号，中括号或大括号。</p><p><img src="https://qiniumedia.freelycode.com/1/d97b7d6d96ba425ab3a4fee75e6d9f10.png" title="" alt="article4.png"/></p><p>紧挨在逗号，分号或冒号前：</p><p><img src="https://qiniumedia.freelycode.com/1/d3cecc6fd4ae4ac09dbba84c36cc408c.png" title="" alt="article4.png"/></p><p>在切片中冒号像一个二元操作符，冒号两侧的有相等数量空格（把它看作最低优先级的操作符）。在一个扩展切片中，两个冒号必须有相等数量的空格。例外：当一个切片参数被省略时，该空格被省略。</p><p><img src="https://qiniumedia.freelycode.com/1/0a1737170228433a97b0706b909c911e.png" title="" alt="article4.png"/></p><p>紧挨着左括号之前，函数调用的参数列表的开始处：</p><p><img src="https://qiniumedia.freelycode.com/1/a9df3fbfe9fe4323b4123b989534c5b1.png" title="" alt="article4.png"/></p><p>紧挨着索引或切片开始的左括号之前：</p><p><img src="https://qiniumedia.freelycode.com/1/3fd6b1e781034d3e8341382370f9c8ac.png" title="" alt="article4.png"/></p><p>为了与另外的赋值（或其它）操作符对齐，不止一个空格。</p><p><img src="https://qiniumedia.freelycode.com/1/f6690e1c424f4aada41932fddcec43ef.png" title="" alt="article4.png"/></p><p><em><br/></em></p><p><em>其它建议</em></p><p><br/></p><p>始终避免行尾空白。因为它们通常不可见，容易导致困惑：如果\后面跟了一个空格，它就不是一个有效的续行符了。很多编辑器不保存行尾空白，CPython项目中也设置了commit前检查以拒绝行尾空白的存在。<br/></p><p>始终在这些二元操作符的两边放置一个空格：赋值（=
 ），增强赋值（+= ，-= 
等），比较（==&nbsp;，&nbsp;&lt;&nbsp;，&nbsp;&gt;&nbsp;，&nbsp;!=&nbsp;，&nbsp;&lt;&gt;&nbsp;，&nbsp;&lt;=&nbsp;，&nbsp;&gt;=&nbsp;，in&nbsp;，&nbsp;not 
in&nbsp;，is&nbsp;，is not&nbsp;），布尔（and ，or ，not ）。<br/>如果使用了不同优先级的操作符，在低优先级操作符周围增加空格（一个或多个）。不要使用多于一个空格，二元运算符两侧空格数量相等。</p><p><img src="https://qiniumedia.freelycode.com/1/70cffeb991514f528bcd0c193629c710.png" title="" alt="article4.png"/></p><p>当=符号用于指示关键字参数或默认参数值时，它周围不要使用空格。</p><p><img src="https://qiniumedia.freelycode.com/1/d0ad0197802049d6975a3d18f2081c24.png" title="" alt="article4.png"/></p><p>带注解的函数使用正常的冒号规则，并且在-&gt;两侧增加一个空格：</p><p><img src="https://qiniumedia.freelycode.com/1/15827126b93144bdb3fbd74e74e2ea21.png" title="" alt="article4.png"/></p><p>如果参数既有注释又有默认值，在等号两边增加一个空格（仅在既有注释又有默认值时才加这个空格）。</p><p><img src="https://qiniumedia.freelycode.com/1/33cd7ccf14e14bcaa8f36acfef8adeef.png" title="" alt="article4.png"/></p><p>不鼓励使用复合语句（同一行有多条语句）。</p><p><img src="https://qiniumedia.freelycode.com/1/0d628f0b3d1a4433958d85956a5cacec.png" title="" alt="article4.png"/></p><p>尽管有时if/for/while的同一行跟一小段代码，在一个多条子句的语句中不要如此。避免折叠长行！</p><p><img src="https://qiniumedia.freelycode.com/1/b75c2e24be5947f183e0580d1483e112.png" title="" alt="article4.png"/></p><p><br/></p><p><strong>什么时候使用尾部逗号？</strong></p><p><br/></p><p>尾部逗号通常都是可选的，除了一些强制的场景，比如元组在只有一个元素的时候需要一个尾部逗号。为了代码更加清晰，元组只有一个元素时请务必用括号括起来（语法上没有强制要求）：</p><p><img src="https://qiniumedia.freelycode.com/1/0780d75e2e1043409f06033fbfd5a6db.png" title="" alt="article4.png"/></p><p>当尾部逗号不是必须时，如果你用了版本控制系统那么它将很有用。当列表元素、参数、导入项未来可能不断增加时，留一个尾部逗号是一个很好的选择。通常的用法是（比如列表）每个元素独占一行，然后尾部都有逗号，在最后一个元素的下一行写闭标签。如果你的数据结构都是写在同一行的，就没有必要保留尾部逗号了。</p><p><img src="https://qiniumedia.freelycode.com/1/4279c7a936924453af5146032b7ff395.png" title="" alt="article4.png"/></p><p><br/></p><p><strong>注释</strong></p><p><br/></p><p>同代码相矛盾的注释比没有注释更差。当代码修改时，始终优先更新注释！<br/><br/>注释应该是完整的句子。如果注释是一个短语或句子，它的第一个单词的首字母应该大写，除非它是一个以小写字母开头的标识符（不更改标识符的情况下！）。<br/><br/>如果注释很短，末尾可以不加句号。注释块通常由一个或多个段落组成，这些段落由完整的句子组成，并且每个句子都应该以句号结尾。<br/><br/>在句尾的句号后边使用两个空格。<br/><br/>写英语注释时，遵循断词和空格。<br/><br/>非英语国家的Python程序员：请用英语书写注释，除非你120%的确定，所有看你代码的人都和你说一样的语言。<br/><br/>非英语国家的Python程序员：请写下你的意见，在英语中，除非你是120%肯定，代码将不会被不讲你的语言的人阅读。<br/></p><p><br/></p><p><strong>注释块</strong><br/></p><p><br/></p><p>注释块通常适用于一些（或全部）紧跟其后的代码，并且那些代码应使用相同级别的缩进。注释块的每行以一个#和一个空格开始（除非注释里面的文本有缩进）。<br/><br/>注释块内的段落之间由仅包含#的行隔开。</p><p><br/></p><p><strong>行内注释</strong></p><p><br/></p><p>谨慎地使用行内注释。<br/><br/>行内注释就是注释和代码在同一行，它与代码之间至少用两个空格隔开。并且它以#和一个空格开始。<br/><br/>如果行内注释指出的是显而易见，那么它就是不必要的。&nbsp; 不要这样做：<br/><img src="https://qiniumedia.freelycode.com/1/a1661d0ca30845c7a59811bbde24e3ad.png" title="" alt="article4.png"/></p><p>但有时，这样是有用的：<br/><img src="https://qiniumedia.freelycode.com/1/c260906321664b229e0c1ffdd957a827.png" title="" alt="article4.png"/></p><p><br/></p><p><strong>文档字符串</strong></p><p><br/></p><p>编写好的文档字符串（即“代码”）约定在PEP 257中是永存的。<br/><br/>为所有公共模块，函数，类和方法书写文档字符串。对非公开的方法书写文档字符串是没有必要的，但应该写注释描述这个方法是做什么的。这些注释应该写在def行后面。<br/>PEP 257描述了好的文档字符串约定。最重要的是，多行文档字符串以一行&quot;&quot;&quot;结束，例如：<br/><img src="https://qiniumedia.freelycode.com/1/122391c27a124ae7996ee3b7d98eba7e.png" title="" alt="article4.png"/></p><p>对于只有一行的文档字符串，&quot;&quot;&quot;同一行上。</p><p><br/></p><p><strong>命名规范</strong></p><p><br/></p><p>Python库的命名规范有点儿混乱，所以我们不会将他们变得完全一致——不过，这是目前推荐的命名标准。新模块和包（包括第三方框架）应该按这些标准书写，但对有不同的风格的已有库，保持内部一致性是首选。</p><p><br/></p><p><strong>根本原则</strong></p><p><br/></p><p>用户可见的API的公开部分的名称，应该遵循反映用法而不是实现的约定。</p><p><br/></p><p><span style="text-decoration: underline;"><em>描述：命名风格</em></span></p><p><br/></p><p>有很多不同的命名风格。它有助于识别使用了什么样的命名风格，这独立于他们的作用。</p><p>下面的命名风格是最常见的：<br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>b（单个小写字母）<br/></p></li><li><p>B（单个大写字母）<br/></p></li><li><p>小写字符串<br/></p></li><li><p>带下划线的小写字符串<br/></p></li><li><p>大写字符串<br/></p></li><li><p>带下划线的大写字符串<br/></p></li><li><p>首字母大写的字符串（或CapWords，或驼峰命名法——因其字母看起来高低不平而得名[3]）。这有时也被称为StudlyCaps。<br/></p></li></ul><p>&nbsp;&nbsp; <span style="font-size: 14px;">注意：当CapWords中使用缩写，大写所有的缩写字母。因此HTTPServerError优于HttpServerError。</span><br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>混用大小写的字符串（与首字母大写字符串不同的是它以小写字母开头）<br/></p></li><li><p>带下划线的首字母大写字符串（令人厌恶的！）<br/></p></li></ul><p><br/>还有一种风格，使用简短独特的前缀组织相关的名字在一起。Python中很少这样用，提一下是为了文档的完整性。例如，os.stat()函数返回一个元祖，它的元素名字通常类似st_mode，st_size，st_mtime等等这样。（这样做是为了强调与POSIX系统调用结构体一致，这有助于程序员熟悉这些。）<br/><br/>X11库的所有的公开函数以X开头。Python中，这种风格通常认为是不必要的，因为属性名和函数名以对象名作前缀，而函数名以模块名作前缀。</p><p><br/></p><p>另外，以下特殊形式，前导或后置下划线是公认的（一般可以与任何约定相结合）：<br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>单前导下划线:弱“内部使用”标志。例如 from M import *不会导入以下划线开头的对象。<br/></p></li><li><p>单后置下划线：按惯例使用避免与Python关键字冲突，例如。<br/></p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-size: 14px;">Tkinter.Toplevel(master, class_=&#39;ClassName&#39;)</span><br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>双前导下划线：当命名类属性，调用时名称改编（类FooBar中，__boo变成 _FooBar__boo；见下文）。<br/></p></li><li><p>前导和后置都是双下划线：存在于用户控制的命名空间的“神奇”的对象或属性。<br/></p></li></ul><p>&nbsp;&nbsp;&nbsp; <span style="font-size: 14px;">例如：__init__，__import__或__file__。不要创造这样的名字；仅像文档中那样使用他们。</span></p><p><br/></p><p><span style="text-decoration: underline;"><em>规定：命名约定</em></span></p><p><br/></p><p><strong>避免采用的名字</strong><br/></p><p><br/></p><p>不要使用字符‘l’（小写字母el），‘O’（大写字母oh）或‘I’（大写字母eye）作为单字符变量名。<br/><br/>在某些字体中，这些字符与数字1和0是没有区别的。当想使用‘l’时，用‘L’代替。</p><p><br/></p><p><strong>包名和模块名</strong><br/></p><p><br/></p><p>模块名应该短，所有的字母小写。可以在模块名中使用下划线来提高可读性。Python包名也应该短，所有的字母小写，不鼓励使用下划线。<br/><br/>当一个C或C++书写的扩展模块，伴随Python模块来提供了一个更高层次（例如更面向对象）的接口时，C/C++模块名有一个前导下划线（如_socket）。</p><p><br/></p><p><strong>类名</strong></p><p><br/></p><p>类名通常使用首字母大写字符串的规则。</p><p>函数的命名规则&nbsp; 主要用来可调用的。<br/></p><p>在接口被记录并且主要用作调用的情况下，用函数的命名规则来代替类名的命名规则。<br/></p><p>注意内置名有一个单独的规则：大多数的内置名是一个单词（或两个单词一起），首字母大写字符串的规则仅用于异常名和内置常量。</p><p><br/></p><p><strong>类型变量名称</strong></p><p><br/></p><p>类型变量名称应该首字母大写，并且尽量短，比如：T, AnyStr, Num。对于协变量和有协变行为的变量，建议添加后缀__co或者__contra。</p><p><img src="https://qiniumedia.freelycode.com/1/8eead9dbc8b3427f937002c33b864ec3.png" title="" alt="article4.png"/></p><p><br/></p><p><strong>异常名</strong></p><p><br/></p><p>因为异常应该是类，所以类的命名规则在这里也同样适用。然而，异常名（如果这个异常确实是一个错误）应该使用后缀“Error”。</p><p><br/></p><p><strong>全局变量名</strong></p><p><br/></p><p>（希望这些变量是在一个模块内使用。）这些规则和那些有关函数的规则是相同的。<br/><br/>模块设计为通过from M import *来使用，应使用__all__机制防止导出全局变量，或使用加前缀的旧规则，为全局变量加下划线（可能你像表明这些全局变量是“非公开模块”）。</p><p><br/></p><p><br/></p><p><strong>函数名</strong><br/></p><p><br/></p><p>函数名应该是小写字母，必要时单词用下划线分开以提高可读性。</p><p>混合大小写仅用于这种风格已经占主导地位的上下文（例如threading.py），以保持向后兼容性。<br/></p><p><br/></p><p><strong>函数和方法参数</strong><br/></p><p><br/></p><p>使用self做实例化方法的第一个参数。<br/></p><p>使用cls做类方法的第一个参数。<br/></p><p>如果函数的参数名与保留关键字冲突，最好是为参数名添加一个后置下划线而不是使用缩写或拼写错误。<br/></p><p>因此class_ 比clss好。（也许使用同义词来避免更好。）。<br/></p><p><br/></p><p><strong>方法名和实例变量</strong><br/></p><p><br/></p><p>采用函数命名规则：小写字母，必要时单词用下划线分开以提高可读性。<br/></p><p>仅为非公开的方法和实例变量使用一个前导下划线。<br/></p><p>为了避免和子类命名冲突，使用两个前导下划线调用Python的名称改编规则。<br/></p><p>Python用类名改编这些名字：如果类Foo有一个属性名为__a，通过Foo.__a不能访问。（可以通过调用Foo._Foo__a来访问。）通</p><p>常，两个前导下划线仅用来避免与子类的属性名冲突。<br/></p><p>注意：关于__names的使用存在一些争论（见下文）。<br/></p><p><br/></p><p><strong>常量</strong><br/></p><p><br/></p><p>常量通常定义于模块级别并且所有的字母都是大写，单词用下划线分开。例如MAX_OVERFLOW和TOTAL。</p><p><br/></p><p><strong>继承的设计</strong><br/><br/><br/>确定类的方法和实例变量（统称为：“属性”）是否公开。如果有疑问，选择非公开；之后把其变成公开比把一个公开属性改成非公开要容易。<br/><br/>公开属性是那些你期望与你的类不相关的客户使用的，根据你的承诺来避免向后不兼容的变更。非公开属性是那些不打算被第三方使用的；你不保证非公开属性不会改变甚至被删除。<br/><br/>非公共属性是那些不打算被第三方使用的，你不能保证非公开的属性不会改变甚至被删除。<br/><br/>此处没有使用术语“private”，因为Python中没有真正私有的属性（没有通常的不必要的工作）。<br/><br/>属性的另一个类别是“API子集”的一部分（在其它语言常被称为“protected”）。某些类被设计为基类，要么扩展，要么修改某些方面的类的行为。在设计这样的类的时候，要注意明确哪些属性是公开的，哪些是API子类的一部分，哪些是真正只在你的基类中使用。<br/><br/><br/>清楚这些之后，这是Python特色的指南：<br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>公开属性没有前导下划线。<br/></p></li><li><p>如果公开属性名和保留关键字冲突，给属性名添加一个后置下划线。这比缩写或错误拼写更可取。（然而，尽管有这样的规定，对于任何类的变量或参数，特别是类方法的第一个参数，‘cls’是首选的拼写方式）<br/></p></li></ul><p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注1：参见上面对类方法的参数名的建议。</span><br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>对于简单的公开数据属性，最好只暴露属性名，没有复杂的访问器/修改器方法。记住，Python为未来增强提供了一条简单的途径，你应该发现简单的数据属性需要增加功能行为。在这种情况下，使用属性来隐藏简单数据属性访问语法后面的功能实现。<br/></p></li></ul><p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注1：特性仅工作于新风格的类。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注2：尽量保持功能行为无副作用，尽管副作用如缓存通常是好的。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注3：计算开销较大的操作避免使用特性，属性注解使调用者相信访问（相对）是廉价的。</span><br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>如果确定你的类会被子类化，并有不想子类使用的属性，考虑用两个前导下划线无后置下划线来命名它们。这将调用Python的名称改编算法，类名将被改编为属性名。当子类不无意间包括相同的属性名时，这有助于帮助避免属性名冲突。<br/></p></li></ul><p><span style="font-size: 14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注1：注意改编名称仅用于简单类名，如果一个子类使用相同的类名和属性名，仍然会有名字冲突。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注2：名称改编会带来一定的不便，如调试和__getattr__()。然而，名称改编算法有良好的文档，也容易手工执行。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注3：不是每个人都喜欢名称改编。尝试平衡避免意外的名称冲突和高级调用者的可能。</span><br/></p><p><br/></p><p><strong>公共和内部接口</strong></p><p><br/></p><p>任何向后兼容性保证只适用于公共接口。因此，重要的是用户能够清楚地区分公开和内部接口。<br/></p><p><br/></p><p>文档接口被认为是公开的，除非文档明确声明他们是临时或内部接口，免除通常的向后兼容保证。所有非文档化的接口应假定为内部接口。<br/></p><p><br/></p><p>为了更好的支持自省，模块应该使用__all__属性显示声明他们公开API的名字， __all__设置为一个空列表表示该模块没有公开API。<br/>即使__all__设置的适当，内部接口（包，模块，类，函数，属性或者其它名字）仍应以一个前导下划线作前缀。<br/></p><p><br/></p><p>一个接口被认为是内部接口，如果它包含任何命名空间（包，模块，或类）被认为是内部的。<br/></p><p><br/></p><p>导入名被认为是实现细节。其它模块必须不依赖间接访问这个导入名，除非他们是一个明确的记录包含模块的API的一部分，例如os.path或包的__init__模块，从子模块暴露功能。<br/><br/><br/><strong>程序设计建议</strong></p><p><br/>编写的代码应该不损害其他方式的Python实现（PyPy，Jython，IronPython，Cython，Psyco等等）。<br/></p><p><br/></p><p>例如，不要依赖CPython的高效实现字符串连接的语句形式
 += b或a = a + 
b。这种优化即使在CPython里也是脆弱的（它只适用于某些类型），并且在不使用引用计数的实现中它完全不存在。在库的性能易受影响的部分，应使用&#39;&#39;.join()形式。这将确保跨越不同实现的连接发生在线性时间。<br/></p><p><br/></p><p>与单值比如None比较使用is 或is not ，不要用等号操作符。<br/></p><p><br/></p><p>同样，如果你真正的意思是if x is not None，谨防编写if x。例如，当测试一个默认是None的变量或参数是否被置成其它的值时。这个其它值可能是在布尔上下文为假的类型（例如容器）。<br/></p><p><br/></p><p>使用is not 操作符而不是not...is。虽然这两个表达式的功能相同，前者更具有可读性并且更优。</p><p><img src="https://qiniumedia.freelycode.com/1/230210c304494dc9866710b505ebdd84.png" title="" alt="article4.png"/></p><p>当实现有丰富的比较的排序操作时，最好实现所有六个操作符（__eq__，__ne__，__lt__，__le__，__gt__，__ge__）而不是依靠其它代码只能进行一个特定的比较。</p><p><br/></p><p>为了减少所涉及的工作量，functools.total_ordering()装饰器提供了一个工具来生成缺失的比较函数。<br/></p><p><br/></p><p>PEP
 207表明，Python假定自反性规则。因此，编译器可以交换y &gt; x和x &lt; y，y &gt;= x和x &lt;= 
y，也可以交换参数x == y和x != y。sort()和min()操作保证使用&lt; 操作符并且max()功能使用&gt; 
操作符。不管怎样，最好实现所有六个操作，这样在其它上下文就不会产生混淆了。</p><p><br/></p><p>使用def语句而不是使用赋值语句将lambda表达式绑定到标识符上。</p><p><img src="https://qiniumedia.freelycode.com/1/784f9712598a49eb83b29a71a707f5ce.png" title="" alt="article4.png"/></p><p>第一种形式意味着所得的函数对象的名称是‘f’而不是一般的‘&lt;lambda&gt;’。这在回溯和字符串表示中更有用。赋值语句的使用消除了lambda表达式可以提供显示def声明的唯一好处（例如它可以嵌在更大的表达式里面）。</p><p><br/></p><p>从Exception而不是BaseException中派生出异常。直接继承BaseException是保留那些捕捉几乎总是错的异常的。<br/></p><p><br/></p><p>设计异常层次结构基于区别，代码可能需要捕获异常，而不是捕获产生异常的位置。旨在以编程方式回答问题“出了什么问题？”，而不是只说“问题产生了”（参见PEP 3151对这节课学习内置异常层次结构的一个例子）<br/></p><p><br/></p><p>类的命名规则适用于此，只是当异常确实是错误的时候，需要在异常类名添加“Error”后缀。用于非本地的流控制或其他形式的信号的非错误的异常，不需要特殊的后缀。<br/></p><p><br/></p><p>适当使用异常链。Python3中，“raise X from Y”用来表明明确的更换而不失去原来追踪到的信息。 <br/></p><p><br/></p><p>当故意替换一个内部异常（Python
 2中使用“raise X”而Python 3.3+中使用“raise X from 
None”），确保相关的细节被转移到新的异常中（比如当转换KeyError为AttributeError时保留属性名，或在新的异常消息中嵌入原始异常的文本）。<br/></p><p><br/></p><p>Python 3中产生异常，使用raise ValueError(&#39;message&#39;)替换老的形式raise ValueError,&#39;message&#39;。<br/></p><p>后一种形式是不合法的Python 3语法。<br/></p><p><br/></p><p>目前使用的形式意味着当异常的参数很长或包含格式化字符传时，多亏了小括号不必再使用续行符。<br/>捕获异常时，尽可能提及特定的异常，而不是使用空的except：子句。<br/>例如，使用：</p><p><img src="https://qiniumedia.freelycode.com/1/a6c03d326d5e461aa0844c3d71c70fbe.png" title="" alt="article4.png"/></p><p>空的except：子句将捕获SystemExit和KeyboardInterrupt异常，这使得很难用Control-C来中断程序，也会掩饰其它的问题。如果想捕获会导致程序错误的所有异常，使用except
 Exception:（空异常相当于except BaseException:）<br/>一条好的经验法则是限制使用空‘except’子句的两种情况：<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.如果异常处理程序将打印或记录跟踪；至少用户将会意识到有错误发生。<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.如果代码需要做一些清理工作，但是随后让异常用raise抛出。处理这种情况用try...finally更好。<br/></p><p>当用一个名字绑定捕获异常时，更喜欢Python2.6中添加的明确的名称绑定语法。</p><p><img src="https://qiniumedia.freelycode.com/1/36dc20b116704e0c8535f0f370e17c27.png" title="" alt="article4.png"/></p><p>这是Python3中唯一支持的语法，并避免与旧的基于逗号的语法有关的歧义问题。<br/></p><p>捕获操作系统异常时，更喜欢Python 3.3引进的明确的异常层次，通过errno值自省。<br/></p><p>另外，对于所有的try/except子句，限制try子句到必须的绝对最少代码量。这避免掩盖错误。</p><p><img src="https://qiniumedia.freelycode.com/1/f00ec66cccfd4c4497e722f6e6165cfe.png" title="" alt="article4.png"/></p><p>当一个资源是一个局部特定的代码段，它使用后用with语句确保迅速可靠的将它清理掉。也可以使用try/finally语句。<br/>无论何时做了除了获取或释放资源的一些操作，应该通过单独的函数或方法调用上下文管理器。例如：</p><p><img src="https://qiniumedia.freelycode.com/1/0fa4cce6d77d4b8cb12375480ab316ae.png" title="" alt="article4.png"/></p><p>后者的例子没有提供任何信息表明__enter__和__exit__方法做了什么除了事务结束后关闭连接。 在这种情况下，明确是很重要的。<br/>返回语句保持一致。函数中的所有返回语句都有返回值，或都没有返回值。如果任意一个返回语句有返回值，那么任意没有返回值的返回语句应该明确指出return None，并且明确返回语句应该放在函数结尾（如果可以）。</p><p><img src="https://qiniumedia.freelycode.com/1/4b81919da0b04a5489456ddd778d40cb.png" title="" alt="article4.png"/></p><p>使用字符串方法代替string模块。</p><p>字符串方法总是更快并且与unicode字符串使用相同的API。如果必须向后兼容Python2.0以前的版本，无视这个原则。<br/>使用“.startswith() ”和“.endswith()”代替字符串切片来检查前缀和后缀。<br/></p><p>startswith()和endswith()更清晰，并且减少错误率。例如：</p><p><img src="https://qiniumedia.freelycode.com/1/98b97e03dadd4f7abbcbd65468953a54.png" title="" alt="article4.png"/></p><p>对象类型的比较使用isinstance()代替直接比较类型。</p><p><img src="https://qiniumedia.freelycode.com/1/a131d402050a448ba72edb533f36db46.png" title="" alt="article4.png"/></p><p>当检查一个对象是否是字符串时，牢记它也可能是一个unicode字符串！Python 2中，str和unicode有共同的基类basestring，所以你可以这么做：</p><p><img src="https://qiniumedia.freelycode.com/1/ac81850474364b1aa023035fe192edcd.png" title="" alt="article4.png"/></p><p>注意，Python3中， unicode和basestring不再存在（只有str），并且字节对象不再是string（而是一个integers序列）<br/>对于序列（字符串，列表，元组），利用空序列是false的事实。</p><p><img src="https://qiniumedia.freelycode.com/1/0b78d3e2d5734f4189b3053e67722878.png" title="" alt="article4.png"/></p><p>不要书写依赖后置空格的字符串。这些后置空格在视觉上无法区分，并且有些编辑器（或最近，reindent.py）将去掉他们。<br/>不要用==来将布尔值与True或False进行比较。</p><p><img src="https://qiniumedia.freelycode.com/1/2efcea0399f04b1491ab88fded008426.png" title="" alt="article4.png"/></p><p>Python标准库不使用函数注解，由于它将给一个特定的注释风格造成过早的承诺。相反，注释是留给用户去发现和试验的有用的注释样式。</p><p><br/></p><p>建议第三方实验注释使用一个相关的修饰符表明解释器如果解释注解来试验注解。<br/></p><p><br/></p><p>早期的核心开发人员尝试使用显示不一致的函数注解，特别的注释风格。例如：<br/></p><p>[str]是模糊的，它是代表一个字符串列表还是一个可以是str或None的值。<br/></p><p><br/></p><p>符号open（file:(str,bytes))被用于值是 bytes或str替代包含一个str紧跟一个bytes值的二元元组。<br/></p><p><br/></p><p>seek(whence:int)注解展示出了一个规定外和规范内的混合：int限制太多（任何与__index__将被允许），它还不够严格（只有值0，1，和2是允许的）。同样的，write(b:bytes)注解也有太多限制（任何支持缓冲协议的将被允许）。<br/></p><p><br/></p><p>有些注解如read1(n:int=None)是自相矛盾的因为None不是一个int值。有些注解如assource_path(self,fullname:str) -&gt; object，令人困惑它的返回类型是什么。<br/></p><p><br/></p><p>除了以上的，注解在具体类型和抽象类型的使用上是不一致的：int与Integral相对，set/frozenset与MutableSet/Set相对。<br/>抽象基类的一些注解是不正确的规范。例如，set-to-set操作需要Other是另一个Set的实例而不是一个Iterable。<br/></p><p>另一个问题是注解成为规范的一部分，但它没有被测试。<br/></p><p><br/></p><p>在大多数情况下，文档字符串已经包含了类型规范，并且比函数注解更清晰。在其余的情况下，一旦注解被移除文档字符串将改进。<br/>所见到的函数注解太特别而且与一个自动类型检查或参数验证的连贯系统不一致。在代码中留下这些注解将使它以后更难做出改变以便自动化工具支持。<br/><br/><strong>脚注</strong></p><p><br/></p><p>[5]悬挂缩进是段落中除第一行之外其它所有行都缩进的格式。在Python中，这个术语用来描述左括号括起来的语句，这行的最后非空白的字符，随后行缩进，直到右括号。<br/></p><p><br/></p><p><strong>参考</strong><br/></p><p><br/></p><p>[1]PEP 7，van Rossum写的C编码风格指南<br/>[2]Barry的GNU Mailman风格指南<br/>&nbsp;http://barry.warsaw.us/software/STYLEGUIDE.txt<br/>[3]http://www.wikipedia.com/wiki/CamelCase<br/>[4]PEP 8现代化，2013年7月http://bugs.python.org/issue18472<br/>版权<br/>这个文档已经放置在公共领域。<br/>来源：https://hg.python.org/peps/file/tip/pep-0008.txt<br/></p><p><br/></p><p style="text-indent: 0em;"><br/></p><blockquote><p style="text-indent: 0em;">英文原文: https://www.python.org/dev/peps/pep-0008/<br/></p><p style="text-indent: 0em;">译者: wangyc<br/> </p></blockquote>
        
      </div>
    </div>
  </div>
  <div class="col-sm-2">
    
      &nbsp;
    
    
  </div>
</div>

</div>
<div id="footer">
  <center>
      <a href="https://python.freelycode.com/fcode/about">关于我</a>&nbsp;|&nbsp;
      <a href="https://python.freelycode.com/fcode/contact">联系方式</a>
  </center>
  <center>诗书塞外的个人Python学习站@2015~2018 &nbsp;&nbsp; All Copy Right Reserved  </center>
  	
  <center><img src="https://qiniumedia.freelycode.com/pythoncircle/img/beianbgs.png" height="18px" width="18px"/><a src="http://www.beian.miit.gov.cn/" style="vertical-align:middle">&nbsp;&nbsp;鄂ICP备13012010号-1</a></center>
</div>
<script type="text/javascript" src="https://qiniumedia.freelycode.com/pythoncircle/js/bootstrap.min.js"></script>
<div style="display:none;">

<script type="text/javascript">
$(function(){
  lrFixFooter("div#footer");  //调用方法：lrFixFooter("div.footerwarp"); 传入底部的类名或者ID名
  function lrFixFooter(obj){
    var footer = $(obj),doc = $(document);
    function fixFooter(){
      if(doc.height()-4 <= $(window).height()){
        footer.css({
          width:"100%",
          position:"absolute",
          left:0,
          bottom:0  
        });
      }else{
        footer.css({
          position:"static"
        });
      }
    }
    fixFooter();
    $(window).on('resize.footer', function(){
      fixFooter();
    });
    $(window).on('scroll.footer',function(){
      fixFooter();
    }); 
  }
});
</script>
</div>
</body>

<!-- Mirrored from python.freelycode.com/contribution/detail/47 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 25 Apr 2022 11:00:00 GMT -->
</html>
